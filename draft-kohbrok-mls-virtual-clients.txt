



Network Working Group                                         K. Kohbrok
Internet-Draft                                                 R. Robert
Intended status: Informational                               Phoenix R&D
Expires: 16 May 2024                                    13 November 2023


                          MLS Virtual Clients
                draft-kohbrok-mls-virtual-clients-latest

Abstract

   This document describes a method that allows multiple MLS clients to
   emulate a virtual MLS client.  A virtual client allows multiple
   emulator clients to jointly participate in an MLS group under a
   single leaf.  Depending on the design of the application, virtual
   clients can help hide metadata and improve performance.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 16 May 2024.

Copyright Notice

   Copyright (c) 2023 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Terminology
   3.  Client emulation
     3.1.  Example protocol flow
     3.2.  DS/AS Details
     3.3.  Agreement on/generation of key material
     3.4.  Coordinating virtual client operations
     3.5.  Possible message re-ordering
     3.6.  Adding emulator clients
     3.7.  Sending application messages
     3.8.  Rotation of authentication key material
   4.  Security considerations
   5.  Privacy considerations
   6.  Performance considerations
     6.1.  Smaller Trees
     6.2.  Fewer blanks
   7.  Emulation costs
   Authors' Addresses

1.  Introduction

   The MLS protocol facilitates communication between clients, where in
   an MLS group, each client is represented by the leaf to which it
   holds the private key material.  In this document, we propose the
   notion of a virtual client that is jointly emulated by a group of
   emulator clients, where each emulator client holds the key material
   necessary to act as the virtual client.

   Depending on the use case, the use of virtual clients can lead to
   performance increases and hide metadata from the DS and other group
   members.  On the other hand, it introduces complexity and additional
   operational requirements.

   We discuss technical challenges and propose a concrete scheme that
   allows a group of clients to emulate a virtual client that can
   participate in one or more MLS groups.

2.  Terminology

   *  Client: An MLS client

   *  Virtual Client: A client the key material of which is held by one
      or more (other) clients.

   *  Emulator Client: A client that collaborates with other emulator
      clients in emulating a virtual client.  Emulator clients can
      themselves be virtual clients.

   TODO: Terminology is up for debate.  We’ve sometimes called this
   “user trees”, but since there are other use cases, we should choose a
   more neutral name.  For now, it’s virtual client emulation.

3.  Client emulation

   To emulate a virtual client, the emulator clients need to agree on
   the key material held by the virtual client and coordinate the
   actions taken by the client in any group of which it is a member.
   The obvious way for the emulator clients to achieve both of these
   tasks is to create an MLS group which we call the emulation group.
   In contrast, we call any group that the virtual client is a member of
   a higher-level group.

3.1.  Example protocol flow

   TODO: Go through a full flow, where both sender and receiver are
   virtual clients.  Include both communication in the higher-level
   group and in the emulation group.

3.2.  DS/AS Details

   Virtual client emulation should be largely agnostic to specific
   details of the AS and DS of the application.  However, a few
   conditions must be met.

   *  Access control: All emulator clients must be able to act as the
      virtual client, including, for example, queue access and
      KeyPackage upload

   *  Queue compatibility: The queue system must allow all emulator
      clients to retrieve messages for the virtual clients.  (Although
      workarounds like one emulator client retrieving messages and then
      sending them to the emulation group are possible.)

3.3.  Agreement on/generation of key material

   Agreement on key material is one of the primary features of MLS and
   the emulator clients can simply export secrets from the emulation
   group to provide the randomness for all key material generated by the
   virtual client throughout its lifetime, especially any MLS-specific
   key material such as leaf encryption keys or init keys.

   This leaves the generation of authentication key material, which can
   also be based on exporters from the emulation group, but which
   otherwise depends on the design of the AS.  In the context of virtual
   clients, one should note, however, that the specifics of the AS can
   influence how well the virtual client hides the metadata of the
   underlying emulator clients.

   TODO: Be more explicit on how the randomness is exported.

3.4.  Coordinating virtual client operations

   Generally, emulator clients should coordinate the actions taken by
   the virtual client.  This is, for example, to prevent multiple
   emulator clients from uploading KeyPackages simultaneously.

   However, emulator clients do not have to coordinate all actions taken
   by the virtual client.  Specifically, commits in a single higher-
   level group can be sent without the risk of desynchronization between
   the emulator clients, as the group’s DS will enforce message
   ordering.  Coordination is thus required for non-commit messages
   (specifically proposals and application messages), as well as actions
   that affect more than one higher-level group (such as credential
   updates, depending on the AS).

3.5.  Possible message re-ordering

   One difficulty in coordinating the use of randomness exported from
   the emulation group is that we cannot assume that messages arrive in
   order.  For example, if an emulator client sends an Update in the
   emulation group and then immediately exports randomness from the new
   epoch to have the virtual client create an update in the higher-level
   group, then other emulator clients might receive the update in the
   higher-level group first.  Since they have not yet received the other
   update, they will have to wait for the emulation group update before
   they can process it.  Depending on the DS, this may or may not
   require specific care.

   TODO: Add a recommendation here, maybe to extract randomness only
   from emulation group epochs that are at least X seconds old, which in
   turn requires clients to keep around randomness, thus potentially
   compromising FS somewhat.

   In addition, since the epochs in the emulation group and higher level
   group are not necessarily correlated, i.e. an emulator client
   performing an update in the higher level group might not at the same
   time perform an update in the emulation group.  The emulator client
   performing the update in the higher level group thus has to signal
   the other emulator clients which emulation group epoch to use to
   export the randomness.

   TODO: Find a good way to signal this to the rest of the emulation
   group.  Options:

   *  AAD of the higher-level group update (leaks metadata to higher-
      level groups, could collide with application-level use of AAD)

   *  Application message to emulation group (subject to message re-
      ordering as described above)

   *  LeafNode extension (leaks metadata to higher-level groups)

3.6.  Adding emulator clients

   If a client is added to the emulation group, it has to be provisioned
   with the private key material and the group states of all higher-
   level groups.  While the latter might be able to be provisioned by
   the higher-level DS, the former has to be provided by another
   emulator client.

   The other emulator client can provide the secret key material used to
   derive all key material relevant to the virtual client (higher-level
   group secrets, KeyPackage secrets, etc.)

   TODO: This means that all such key material must be derived in a
   well-separated and forward-secure way.  (See TODO above to specify
   further details on how to derive key material for the virtual
   client.)

   Since the new emulator client can only emulate the virtual client if
   it has access to those secrets, it cannot join the emulation group
   via external commit, except if said secrets are provided
   asynchronously.

3.7.  Sending application messages

   Open Question: Key material for encryption/decryption of application
   messages is used only once.  Since there is no ordering of
   application messages (per client) on the DS, emulator clients could
   have the same virtual client send an application message at the same
   time, both using the same key material.  When those messages arrive
   at a recipient, the recipient won’t be able to decrypt the second
   message, because the recipient has already discarded the required key
   material.  How to avoid this?  A few ideas:

   *  Key generation allotments: Clients in the emulation group use the
      ratchet generation modulo their leaf index in the emulation group.
      (Leaks metadata to higher-level groups, potentially requires all
      other higher-level group members to store lots of intermediary key
      generations, could confuse applications if they derive message
      ordering from key generations, could make recipients think that
      they missed messages)

   *  More complex secret tree (or separate secret tree): Instead of a
      single ratchet at the leaf of the secret tree, there is another
      tree with one ratchet for each emulator client. (extra costs for
      PPRF, leaks metadata, requires an extension, either an unsafe one
      (if the original secret tree is modified), or a safe one that
      defines its own application message (if a new secret tree is
      used))

3.8.  Rotation of authentication key material

   If the design of the AS specifies the use of cross-group
   authentication key material, emulator clients must coordinate the
   rotation of said key material in the emulation group to avoid
   multiple emulator clients rotating a key at the same time.  Details
   depend on the design of the AS.

4.  Security considerations

   TODO: Detail security considerations once the protocol has evolved a
   little more.  Starting points:

   Some of the performance benefits of this scheme depend on the fact
   that one can update once in the emulation group and “re-use” the new
   randomness for updates in multiple higher-level groups.  At that
   point, clients only really recover when they update the emulation
   group, i.e. re-using somewhat old randomness of the emulation group
   won’t provide real PCS in higher-level groups.

5.  Privacy considerations

   TODO: Specify the metadata hiding properties of the protocol.  The
   details depend on how we solve some of the problems described
   throughout this document.  However, using a virtual client should
   mask add/remove activity in the underlying emulation group.  If it
   actually hides the identity of the members may depend on the details
   of the AS, as well as how we solve the application messages problem.

6.  Performance considerations

   There are several use cases, where a specific group of clients
   represents a higher-level entity such as a user, or a part of an
   organization.  If that group of clients shares membership in a large
   number of groups, where its sole purpose is to represent the higher-
   level entity, then instead emulating a virtual client can yield a
   number of performance benefits, especially if this strategy is
   employed across an implementation.  Generally, the more emulator
   clients are hidden behind a single virtual client and the more
   clients are replaced by virtual clients, the higher the potential
   performance benefits.

6.1.  Smaller Trees

   As a general rule, groups where one or more sets of clients are
   replaced by virtual clients have fewer members, which leads to
   cheaper MLS operations where the cost depends on the group size,
   e.g., commits with a path, the download size of the group state for
   new members, etc.  This increase in performance can offset
   performance penalties, for example, when using a PQ-secure cipher
   suite, or if the application requires high update frequencies
   (deniability).

6.2.  Fewer blanks

   Blanks are typically created in the process of client removals.  With
   virtual clients, the removal of an emulator client will not cause the
   leaf of the virtual client (or indeed any node in the virtual
   client’s direct path) to be blanked, except if it is the last
   remaining emulator client.  As a result, fluctuation in emulator
   clients does not necessarily lead to blanks in the group of the
   corresponding virtual clients, resulting in fewer overall blanks and
   better performance for all group members.

7.  Emulation costs

   From a performance standpoint, using virtual clients only makes sense
   if the performance benefits from smaller trees and fewer blanks
   outweigh the performance overhead incurred by emulating the virtual
   client in the first place.

Authors' Addresses

   Konrad Kohbrok
   Phoenix R&D
   Email: konrad.kohbrok@datashrine.de


   Raphael Robert
   Phoenix R&D
   Email: ietf@raphaelrobert.com
