



Network Working Group                                         K. Kohbrok
Internet-Draft                                                 R. Robert
Intended status: Informational                               Phoenix R&D
Expires: 23 May 2024                                    20 November 2023


                          MLS Virtual Clients
                draft-kohbrok-mls-virtual-clients-latest

Abstract

   This document describes a method that allows multiple MLS clients to
   emulate a virtual MLS client.  A virtual client allows multiple
   emulator clients to jointly participate in an MLS group under a
   single leaf.  Depending on the design of the application, virtual
   clients can help hide metadata and improve performance.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 23 May 2024.

Copyright Notice

   Copyright (c) 2023 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Terminology
   3.  Client emulation
     3.1.  Path Secrets
     3.2.  Example protocol flow
     3.3.  DS/AS Details
     3.4.  Agreement on/generation of key material
     3.5.  Coordinating virtual client operations
     3.6.  Possible message re-ordering
     3.7.  Adding emulator clients
     3.8.  Sending application messages
       3.8.1.  PPRF-based Challenges
     3.9.  Rotation of authentication key material
   4.  Security considerations
   5.  Privacy considerations
   6.  Performance considerations
     6.1.  Smaller Trees
     6.2.  Fewer blanks
   7.  Emulation costs
   Authors' Addresses

1.  Introduction

   The MLS protocol facilitates communication between clients, where in
   an MLS group, each client is represented by the leaf to which it
   holds the private key material.  In this document, we propose the
   notion of a virtual client that is jointly emulated by a group of
   emulator clients, where each emulator client holds the key material
   necessary to act as the virtual client.

   Depending on the use case, the use of virtual clients can lead to
   performance increases and hide metadata from the DS and other group
   members.  On the other hand, it introduces complexity and additional
   operational requirements.

   We discuss technical challenges and propose a concrete scheme that
   allows a group of clients to emulate a virtual client that can
   participate in one or more MLS groups.

2.  Terminology

   *  Client: Any MLS client including emulator clients, virtual clients
      and real clients.

   *  Real Client: An MLS client whose secret key material is help by a
      single agent.

   *  Virtual Client: A client for which the secret key material is held
      by one or more other clients, each of which can act as the virtual
      client.

   *  Emulator Client: A client that collaborates with other emulator
      clients in emulating a virtual client.  Emulator clients can be
      real or virtual clients.

   *  Heirarchical group: A generalization of an MLS group in which
      members can be either virtual or real clients.  Heirarchical group
      members may also act as emulator clients to collaboratively
      emulate a virtual client representing the heirarchical group in
      one or more other heirarchical groups.

   *  Group representative: A group representative of (heirarchical
      group) A in (heirarchical group) B is a virtual client that is
      member of group B while being emulated by the clients in group A.

   *  Subgroup: a heirarchical group with a representative in one or
      more other groups.

   *  Supergroup: a heirarchical group with one or more virtual members.

   TODO: Terminology is up for debate.  We’ve sometimes called this
   “user trees”, but since there are other use cases, we should choose a
   more neutral name.  For now, it’s virtual client emulation.

3.  Client emulation

   A set of emulator clients that want to emulate a virtual client R in
   a group S form their own MLS heirarchical group G (seperate from S).
   They export secrets from G with which each emulator client can
   deterministically derive all key material for R's leaf in S.  This
   makes G a subgroup of S and R the representative of G in S.  G may
   have representatives in 0 or more supergroups but can have at most 1
   representative in each supergroup.  A commit in G creates a new key
   schedule for G which results in emulator clients deriving new key
   material for the representatives of G.  Therefor, a commit in G
   SHOULD be accompanied by commits or updates in all supergroups of G
   transitioning the G's representative in the supergroup to the new
   leaf key material.

3.1.  Path Secrets

   Besides representatives' leaf keys, emulator clients must also
   synchronize the other secrets held by representatives.  For this, a
   client commit

   When emulator clients create commits acting as a representative they
   derive the path secret

   in G need to agree on the key material held by the virtual client R
   in order to act as R in the supergroup S of which R is a member.  For
   this the emulator clients form

   and coordinate the actions taken by the client in any group of which
   it is a member.  The obvious way for the emulator clients to achieve
   both of these tasks is to create an MLS group which we call the
   emulation group.  In contrast, we call any group that the virtual
   client is a member of a higher-level group.

   OPEN QUESTIONS - A subgroup G may have at most one representative R
   in supergroups S?  - What to say about synchronization between sub/
   super groups.  What must/should/can happen after a commit in sub
   group?  Commit in super group?  Is just an update prop OK?  What if
   the prop doesnt get commited for some reason?  E.g. no commit is sent
   in supergroup.  - How to derive supergroup key material? (1) Purly
   off sub-group key schedule? (2) using further entropy sampled at time
   of commit to supergroup?  - Pro: simple.  Con: Creates conflict
   between meta-data hiding vs. PCS.  Bad for bandwidth.  - PCS vs.
   metadata: Either commit to all supergroups at same time as each other
   + subgroup (good for PCS) but bad for meta-data hiding.  Or delay (or
   even drop) supergroup commits which is bad for PCS because leaking
   emulator clients state today can reveal the entropy for a supergroup
   commit they do tomorrow.  Entropy for supergroup is effectively
   sampled long before use.  Bandwidth: needing to commit in a
   supergroup ==> new supergroup leaf KEM key ==> need subgroup key
   commit ==> need commit in all other supergroups.  - For (2) e.g. to
   commit in supergroup, sample fresh commit_seed, send to subgroup (app
   msg?), derive supergroup keys off subgroup key schedule +
   commit_seed.

3.2.  Example protocol flow

   TODO: Go through a full flow, where both sender and receiver are
   virtual clients.  Include both communication in the higher-level
   group and in the emulation group.

3.3.  DS/AS Details

   Virtual client emulation should be largely agnostic to specific
   details of the AS and DS of the application.  However, a few
   conditions must be met.

   *  Access control: All emulator clients must be able to act as the
      virtual client, including, for example, queue access and
      KeyPackage upload

   *  Queue compatibility: The queue system must allow all emulator
      clients to retrieve messages for the virtual clients.  (Although
      workarounds like one emulator client retrieving messages and then
      sending them to the emulation group are possible.)

3.4.  Agreement on/generation of key material

   Agreement on key material is one of the primary features of MLS and
   the emulator clients can simply export secrets from the emulation
   group to provide the randomness for all key material generated by the
   virtual client throughout its lifetime, especially any MLS-specific
   key material such as leaf encryption keys or init keys.

   This leaves the generation of authentication key material, which can
   also be based on exporters from the emulation group, but which
   otherwise depends on the design of the AS.  In the context of virtual
   clients, one should note, however, that the specifics of the AS can
   influence how well the virtual client hides the metadata of the
   underlying emulator clients.

   TODO: Be more explicit on how the randomness is exported.

3.5.  Coordinating virtual client operations

   Generally, emulator clients should coordinate the actions taken by
   the virtual client.  This is, for example, to prevent multiple
   emulator clients from uploading KeyPackages simultaneously.

   However, emulator clients do not have to coordinate all actions taken
   by the virtual client.  Specifically, commits in a single higher-
   level group can be sent without the risk of desynchronization between
   the emulator clients, as the group’s DS will enforce message
   ordering.  Coordination is thus required for non-commit messages
   (specifically proposals and application messages), as well as actions
   that affect more than one higher-level group (such as credential
   updates, depending on the AS).

3.6.  Possible message re-ordering

   One difficulty in coordinating the use of randomness exported from
   the emulation group is that we cannot assume that messages arrive in
   order.  For example, if an emulator client sends an Update in the
   emulation group and then immediately exports randomness from the new
   epoch to have the virtual client create an update in the higher-level
   group, then other emulator clients might receive the update in the
   higher-level group first.  Since they have not yet received the other
   update, they will have to wait for the emulation group update before
   they can process it.  Depending on the DS, this may or may not
   require specific care.

   TODO: Add a recommendation here, maybe to extract randomness only
   from emulation group epochs that are at least X seconds old, which in
   turn requires clients to keep around randomness, thus potentially
   compromising FS somewhat.

   In addition, since the epochs in the emulation group and higher level
   group are not necessarily correlated, i.e. an emulator client
   performing an update in the higher level group might not at the same
   time perform an update in the emulation group.  The emulator client
   performing the update in the higher level group thus has to signal
   the other emulator clients which emulation group epoch to use to
   export the randomness.

   TODO: Find a good way to signal this to the rest of the emulation
   group.  Options:

   *  AAD of the higher-level group update (leaks metadata to higher-
      level groups, could collide with application-level use of AAD)

   *  Application message to emulation group (subject to message re-
      ordering as described above)

   *  LeafNode extension (leaks metadata to higher-level groups)

3.7.  Adding emulator clients

   If a client is added to the emulation group, it has to be provisioned
   with the private key material and the group states of all higher-
   level groups.  While the latter might be able to be provisioned by
   the higher-level DS, the former has to be provided by another
   emulator client.

   The other emulator client can provide the secret key material used to
   derive all key material relevant to the virtual client (higher-level
   group secrets, KeyPackage secrets, etc.)

   TODO: This means that all such key material must be derived in a
   well-separated and forward-secure way.  (See TODO above to specify
   further details on how to derive key material for the virtual
   client.)

   Since the new emulator client can only emulate the virtual client if
   it has access to those secrets, it cannot join the emulation group
   via external commit, except if said secrets are provided
   asynchronously.

3.8.  Sending application messages

   Open Question: Key material for encryption/decryption of application
   messages is used only once.  Since there is no ordering of
   application messages (per client) on the DS, emulator clients could
   have the same virtual client send an application message at the same
   time, both using the same key material.  When those messages arrive
   at a recipient, the recipient won’t be able to decrypt the second
   message, because the recipient has already discarded the required key
   material.  How to avoid this?  A few ideas:

   *  Key generation allotments: Clients in the emulation group use the
      ratchet generation modulo their leaf index in the emulation group.
      (Leaks metadata to higher-level groups, potentially requires all
      other higher-level group members to store lots of intermediary key
      generations, could confuse applications if they derive message
      ordering from key generations, could make recipients think that
      they missed messages)

   *  More complex secret tree (or separate secret tree): Instead of a
      single ratchet at the leaf of the secret tree, there is another
      tree with one ratchet for each emulator client. (extra costs for
      PPRF, leaks metadata, requires an extension, either an unsafe one
      (if the original secret tree is modified), or a safe one that
      defines its own application message (if a new secret tree is
      used))

3.8.1.  PPRF-based Challenges

   Key/nonce pairs used to encrypt application messages are derived
   using a PPRF.  That is, the Secret Tree in the super group is
   replaced by a GGM-style PPRF initially keyed by the
   encryption_secret.  To send an application messaage, the sending
   emulator client choose a 32 byte challenge and includes it in the
   authenticated_data field in the PrivateMessage struct.  To derive the
   nonce and AEAD key for the application message the PPRF is evaluated
   (and punctured) the PPRF at the challenge.  Due to the entropy in the
   challenge nonce-reuse guards can be dropped.

   Advantages: - Group Structure Agnostic : The construction is agnostic
   to all aspects of the group's membership structure.  For example,
   clients can receive application messages without knowing the sender's
   leaf index in it's virtual client nor the relative position of the
   sender's virtual client in the hiearchy of virtual clients making up
   the super group. - Metadata Hiding: The scheme hides everything about
   a sender's position in the groups membership heirachy beyond what is
   revealed by the signature.  For example, application messages are as
   unlinkabel as permited by their signatures (even for other emulation
   clients in the same virtual client). - Forward Security Sender
   Anonymity : Leaking a clients PPRF local state reveals nothing about
   who sent previously received application messages.  This includes
   both hiding both the sending emulation clients and even their virtual
   clients.

   Disadvantages: - Breaks the RFC9420 specification & requires an un-
   safe extension. - Applications messages have an added 28 byte
   overhead. - Senders need 28 additional random bytes to send an
   application message. - A decryption error occurs when receiving an
   application message with a previously used challenge (in the current
   epoch).

   There is a trade-off between cost and error probability when choosing
   b; the bit-length of challenges.  (Above b = 256 which is very
   conservative.) - Sending two application messages with the same
   challenge in an epoch immediatly leaks the XOR of the two plaintexts
   and results in decryption failures for which ever message a client
   receives second.  The probability a challenge gets re-used when k
   application messages with b-bit challenges are sent in an epoch
   (without any coordination) is err = 1-[C(2^b,k)/C(2^b+k-1)].  So
   larger b reduces the probability of challenge re-use exponentially. -
   Evaluating the PPRF requires up to b HKDF calls and new 32B values to
   be stored locally by the client.  Moreover, b-bit challenges impost a
   8b-4 bytes of overhead in application messages and added random bits
   when sending.

3.9.  Rotation of authentication key material

   If the design of the AS specifies the use of cross-group
   authentication key material, emulator clients must coordinate the
   rotation of said key material in the emulation group to avoid
   multiple emulator clients rotating a key at the same time.  Details
   depend on the design of the AS.

4.  Security considerations

   TODO: Detail security considerations once the protocol has evolved a
   little more.  Starting points:

   Some of the performance benefits of this scheme depend on the fact
   that one can update once in the emulation group and “re-use” the new
   randomness for updates in multiple higher-level groups.  At that
   point, clients only really recover when they update the emulation
   group, i.e. re-using somewhat old randomness of the emulation group
   won’t provide real PCS in higher-level groups.

5.  Privacy considerations

   TODO: Specify the metadata hiding properties of the protocol.  The
   details depend on how we solve some of the problems described
   throughout this document.  However, using a virtual client should
   mask add/remove activity in the underlying emulation group.  If it
   actually hides the identity of the members may depend on the details
   of the AS, as well as how we solve the application messages problem.

6.  Performance considerations

   There are several use cases, where a specific group of clients
   represents a higher-level entity such as a user, or a part of an
   organization.  If that group of clients shares membership in a large
   number of groups, where its sole purpose is to represent the higher-
   level entity, then instead emulating a virtual client can yield a
   number of performance benefits, especially if this strategy is
   employed across an implementation.  Generally, the more emulator
   clients are hidden behind a single virtual client and the more
   clients are replaced by virtual clients, the higher the potential
   performance benefits.

6.1.  Smaller Trees

   As a general rule, groups where one or more sets of clients are
   replaced by virtual clients have fewer members, which leads to
   cheaper MLS operations where the cost depends on the group size,
   e.g., commits with a path, the download size of the group state for
   new members, etc.  This increase in performance can offset
   performance penalties, for example, when using a PQ-secure cipher
   suite, or if the application requires high update frequencies
   (deniability).

6.2.  Fewer blanks

   Blanks are typically created in the process of client removals.  With
   virtual clients, the removal of an emulator client will not cause the
   leaf of the virtual client (or indeed any node in the virtual
   client’s direct path) to be blanked, except if it is the last
   remaining emulator client.  As a result, fluctuation in emulator
   clients does not necessarily lead to blanks in the group of the
   corresponding virtual clients, resulting in fewer overall blanks and
   better performance for all group members.

7.  Emulation costs

   From a performance standpoint, using virtual clients only makes sense
   if the performance benefits from smaller trees and fewer blanks
   outweigh the performance overhead incurred by emulating the virtual
   client in the first place.

Authors' Addresses

   Konrad Kohbrok
   Phoenix R&D
   Email: konrad.kohbrok@datashrine.de


   Raphael Robert
   Phoenix R&D
   Email: ietf@raphaelrobert.com
