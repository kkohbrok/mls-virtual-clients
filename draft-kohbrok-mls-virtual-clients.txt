



Network Working Group                                         K. Kohbrok
Internet-Draft                                                 R. Robert
Intended status: Informational                               Phoenix R&D
Expires: 24 May 2024                                    21 November 2023


                          MLS Virtual Clients
                draft-kohbrok-mls-virtual-clients-latest

Abstract

   This document describes a method that allows multiple MLS clients to
   emulate a virtual MLS client.  A virtual client allows multiple
   emulator clients to jointly participate in an MLS group under a
   single leaf.  Depending on the design of the application, virtual
   clients can help hide metadata and improve performance.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 24 May 2024.

Copyright Notice

   Copyright (c) 2023 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Tenets
   3.  Terminology
   4.  Client emulation
     4.1.  Generating Virtual Client Secrets
     4.2.  Key Package
     4.3.  Commits in Supergroups.
     4.4.  Update Proposals in Supergroups.
       4.4.1.  Sub-goup Membership Change
     4.5.  Challenge-Based Application Messages.
     4.6.  Adding and Removing Emulator Clients
     4.7.  Example protocol flow
     4.8.  DS/AS Details
     4.9.  Agreement on/generation of key material
     4.10. Coordinating virtual client operations
     4.11. Possible message re-ordering
     4.12. Adding emulator clients
     4.13. Sending application messages
       4.13.1.  PPRF-based Challenges
     4.14. Rotation of authentication key material
   5.  Security considerations
   6.  Privacy considerations
   7.  Performance considerations
     7.1.  Smaller Trees
     7.2.  Fewer blanks
   8.  Emulation costs
   Authors' Addresses

1.  Introduction

   The MLS protocol facilitates communication between clients, where in
   an MLS group, each client is represented by the leaf to which it
   holds the private key material.  In this document, we propose the
   notion of a virtual client that is jointly emulated by a group of
   emulator clients, where each emulator client holds the key material
   necessary to act as the virtual client.

   Depending on the use case, the use of virtual clients can lead to
   performance increases and hide metadata from the DS and other group
   members.  On the other hand, it introduces complexity and additional
   operational requirements.

   We discuss technical challenges and propose a concrete scheme that
   allows a group of clients to emulate a virtual client that can
   participate in one or more MLS groups.

2.  Tenets

   Guiding principles and goals to work towards.

   *  Minimize number of required commits.  Especially, interdependent
      ones across groups.

   *  Simplicity & clarity > efficiency

   *  Real vs. virtual client members look the same to the rest of the
      group.

   *  Compatible with standard MLS DS.

   *  Virtual clients should look like real clients to the DS.

3.  Terminology

   *  Client: Any MLS client including emulator clients, virtual clients
      and real clients.

   *  Real Client: An MLS client whose secret key material is help by a
      single agent.

   *  Virtual Client: A client for which the secret key material is held
      by one or more other clients, each of which can act as the virtual
      client.

   *  Emulator Client: A client that collaborates with other emulator
      clients in emulating a virtual client.  Emulator clients can be
      real or virtual clients.

   *  Heirarchical group: A generalization of an MLS group in which
      members can be either virtual or real clients.  Heirarchical group
      members may also act as emulator clients to collaboratively
      emulate a virtual client representing the heirarchical group in
      one or more other heirarchical groups.

   *  Group representative: A group representative of (heirarchical
      group) G is a virtual client emulated by the clients in G.  The
      group representative of group G in another group S is the
      representative of G that is a member S.

   *  Subgroup: a heirarchical group with a representative in one or
      more other groups.

   *  Supergroup: a heirarchical group with one or more virtual members.

   TODO: Terminology is up for debate.  We’ve sometimes called this
   “user trees”, but since there are other use cases, we should choose a
   more neutral name.  For now, it’s virtual client emulation.

4.  Client emulation

   A set of emulator clients that want to emulate one or more virtual
   clients form an MLS heirarchical group G.  To act as a virtual client
   R representing G the emulating clients in G must each learn all
   secret held by R.  This includes secrets associated with R's key
   packages and leaf nodes in groups R is a member of.  This is done by
   deriving any such secrets deterministically using seeds exported from
   G's key schedule.  To help coordinate this, the emulator client that
   first creates a representative R of group G assigns R a virtual
   client ID unique among all representatives of G.  Similarly, as part
   of their creation, each key package of R is assigned an ID unique
   among all key packages generated for R using the same epoch's key
   schedule.

   Just like real clients, a virtual client R can join or create any
   group S and even be an emulator client for some other virtual client.
   If R joins a group S then this makes G a subgroup of supergroup S and
   with R being G's representative in S.  G may have 0 or more
   representatives which can each be a member of 0 or more supergroups.
   G and all of its supergroups MUST have unique group IDs.  G can have
   at most 1 representative in a supergroup S.

4.1.  Generating Virtual Client Secrets

   For each epoch in G members use the Safe API's FS-Export method to
   obtain the virtual_client_seed for the epoch.

 virtual_client_seed = MLS-FS-Export("Virtual Client Seed", "", HKDF.Nh)

   Later, they derive further seeds from virtual using the following
   context struct.

struct {
  uint16 virtual_client_ID;
  uint32 emulator_client_leaf_index;
  opaque emulator_group_context_hash;
  opaque extended_context
} VClientSeedContext

seed = ExpandWithLabel(virtual_client_seed, "Virtual Client Secrets", VClientSeedContext)

   OPEN QUESTION

   *  Reasons why we should use FS-Exporter(), not Exporter(): Want to
      ensure immediate FS when sks derived from seeds deleted with out
      requireing subgroup commit just to erase exporter_secret.
      Scenario 1: Gen KP.  KP used for Welcome msg.  Process Welcome to
      join supergroup S.  Delete init_key sk.  Now we want FS for
      init_key to kick in immediatly (i.e. without having to first move
      G to a new epoch to clear out its exporter_secret.)  Scenario 2:
      Commit in supergroup to get leaf node LN1.  Gen update for
      supergroup.  Update commited in supergroup to get leafe node LN2.
      Delete LF1 sks.  We want FS for LF1 without needing a commit in
      subgroup to force delete exporter_secret.

   *  Do we care if two emulator clients produce the same commits or
      proposals concurrently but with different signatures and nonce-
      reuse guard?  Similar question for one emulator client producing
      two similar KPs or updates.  I dont think its a security issue?
      Just a bit messy.  Could reveal that a client is virtual not real
      though?  If we do care then could add emulator client's leaf_index
      and a seed_counter to ReKeySeedContext.  Mitigates problem because
      now seed collisions only possible under quite limited
      circumstances.

   *  How to coordinate KeyPackage IDs?  We could use an extension in
      the KP to signal its KPID to other emulator clients.  But if we
      avoid that, then a virtual clients KP could look identical to that
      of a real client which would be cool.  Maybe signal KPIDs for
      upcoming KP's in a commit to G?  Seems robust (guarantees
      coordination and avoids collisions on KPIDs) but also a bit
      limiting.  If decide I want to generate a new KP for a
      representative I now first have to commit in G but not for
      security, just to tell people the new KPID.  But application msgs
      aren't even guaranteed to arrive so is that ok?  Also should we
      use explicite KPIDs? or is it ok to use the init_key in the KP as
      the KPID?

4.2.  Key Package

   If this is a new representative then first choose VCID.  Choose fresh
   KPID(s).  Commit in G anouncing (VCID and) KPIDs privatly to the
   group.  Generate KPs from new epochs key schedule using VCID and KPID
   in the context.

   struct {
     uint16 key_package_ID;
     opaque pre-seed[HKDF.Nh];
   } KPSeedContext

   OPEN QUESTIONS

   Not sure how to provide immediate FS for consumed virtual client key
   packages.  Some strawmen designs I can think of right now are:

   1.  use FS-Exporter to get kp_tree_secret.  Initilize a PPRF = MLS
       Secret Tree with root kp_tree_secret.  Use
       PPRF(emulator_client_leaf, KP_generation) to get an FS key k.
       Set kp_seed := HKDF(k, pre-seed, VClientSeedContext) with fresh
       random pre-seed to get PCS for kp_seed.  Generate KP secrets
       using kp_seed. delete k and kp_seed.  At any time, delete KP
       secrets get immediate FS for the KP.

   2.  use MLS-Exporter with fresh random pre-seed as label to get
       kp_seed with PCS.  Force subgroup commit when a KP consumed to
       ensure exporter_secret deleted for FS.

   3.  use FS-Export to get kp_seed + generating a KP requires first
       anouncing to subgroup in a subgroup commit.  PCS from subgroup
       commit PCS.  FS because FS-Exporter.

   The hard part is minimizing the need for (subgroup) commits while
   ensuring immediate FS for consumed KPs. (1)-(3) solve this with
   different trade-offs:

   1.  imposes largest local state and compute cost but also requires no
       commits and has optimal PCFS for KPs.  Requires subgroup App Msgs
       (or somethign similar) to coordinate when KPs generated.

   2.  simpler than 1. but imposes commit dependency between super/sub
       groups.  Probably makes FS for supergroup welcome msgs more
       complicated to ensure.  What if subgroup commit fails for some
       reason?  Which emulator client should issue subgroup commit to
       avoid "stampeding herd"? requires subgroup App Msg to coordinate
       secrets when KP created.

   3.  simpler than 1. & avoids stampeding herd but still imposes
       subgroup commit as pre-req to generating KPs.  Also grows PCS
       window for KP to subgroup commit time instead of actual KP
       generation time.  No App Msg needed (because uses commit to
       coordinate instead).

   TODO

   *  If the KPSeedContext struct ends up with just one uint16 in it we
      can remove it again and use the uint16 directly instead.

4.3.  Commits in Supergroups.

   To commit as a representative in supergroup S, first commit in
   subgroup G.  Next use new epoch's FS-Exporter to derive new leaf node
   and path secret for representative's commit in S.  In
   VClientSeedContext include S's GroupContext to avoid collisions
   between supergroups.

   struct {
     uint8 rekey_seed[AEAD.Nk];
     opaque supergroup_context_hash;
   } ReKeySeedContext

   OPEN QUESTIONS

   *  How can clients send private and authenticated extension-specific
      data along with a commit?  Maybe Safe API can give wrap
      authenticated_data in FramedContent to give extensions a safe way
      to do this?  E.g. we want to communicate "This subgroup commit
      creates an epoch from which I'm deriving the seeds for a virtual
      client R in supergroup G with commit

4.4.  Update Proposals in Supergroups.

   OPEN QUESTIONS

   *  Raises similar questions as for KPs.  How to minimize commits
      while getting PFCS for leaf_node in Updates.

4.4.1.  Sub-goup Membership Change

   Commits in subgroup are just like for MLS with the following
   additions.

   *  Privately send all representatives' states to new members in
      welcome message.

   *  When removing subgroup members MUST expire all representatives'
      secrets.  KP's deleted (and replaced).  Commits (or updates) in
      all supergroups. (pfui!)  Security Consideration: Remove from
      subgroup not complete until all old KP's revoked, supergroup
      commits done, and update proposals commited too in supergroup.

   OPEN QUESTIONS

   *  What to do about external joins? "clients obtain representatives'
      states out-of-band"? external joiners can revoke & replace
      reprsentatives' KPs?

4.5.  Challenge-Based Application Messages.

   Needed so that emulator clients dont collide on key/nonce pairs when
   concurrently sending in a supergroup.  See random-access mode in git
   branch app-msgs for details.

   Application messages are used to send two types of information about
   to a.  Either higher-level application data or information about an
   action taken by an emulator client on behalf of a group's
   representative.  The following struct encodes application messages
   signaling their purpose to receivers.

   enum {
     reserved(0),
     virtual_client_info(1),
     application_message(2),
     (255)
   } ApplicationMessageType

   enum {
     reserved(0),
     key_package(1),
     propsal(2),
   } VirtualClientAction

   struct {
     ApplicationMessageType app_msg_type;
     select (ApplicationMessage.app_msg_type) {
       case application_message:
         opaque application_data<V>;

       case virtual_client_info:
         VirtualClientAction virtual_client_action;
         select (ApplicationMessage.virtual_client_action) {
           case key_package:
             KeyPackage key_package;
             VClientSeedContext seed_context;

           case propsal:
             Proposal proposal
             select (ApplicationMessage.propsal.proposal_type)
               case update:  ReKeySeedContext rekey_seed_context;
             }
         }
     }
   } ApplicationMessage

   OPEN QUESTIONS

   *  How should clients communicate about VirtClient commits, KPs,
      proposals, etc.  E.g. if Alice creates a new KP for a virt client,
      what should she send about it the other emulator clients? the
      entire KP? just its KeyPackageRef?  Or the specific parameters
      used to generate it (capabilities, ciphersuite, extensions,...).
      Sending entire KP to emulator group (e.g. as an app msgs) could
      mean better backwards compat with a standard MLS DS.  (An MLS DS
      has no concept of "Give me a KP, but don't pop it from its queue"
      let alone something like "give me the KP with init_key X" or
      whatever.)  On the other hand sending over whole KP to the
      emulator group could be very redundant.  In many (most?)
      applications there's likely little to no choice when creating a KP
      besides sampling keys and the coins for the signature.  So sending
      over the KPID and signatures for a new KP is enough for other
      emulator clients to reconstruct the entire KP locally for
      themselves.

   *  Similar question for proposals.

4.6.  Adding and Removing Emulator Clients

   Send them the local states of all representativs of G encrypted in
   their welcome message.  No action needs to be taken in any super
   group.

4.7.  Example protocol flow

   TODO: Go through a full flow, where both sender and receiver are
   virtual clients.  Include both communication in the higher-level
   group and in the emulation group.

4.8.  DS/AS Details

   Virtual client emulation should be largely agnostic to specific
   details of the AS and DS of the application.  However, a few
   conditions must be met.

   *  Access control: All emulator clients must be able to act as the
      virtual client, including, for example, queue access and
      KeyPackage upload

   *  Queue compatibility: The queue system must allow all emulator
      clients to retrieve messages for the virtual clients.  (Although
      workarounds like one emulator client retrieving messages and then
      sending them to the emulation group are possible.)

4.9.  Agreement on/generation of key material

   Agreement on key material is one of the primary features of MLS and
   the emulator clients can simply export secrets from the emulation
   group to provide the randomness for all key material generated by the
   virtual client throughout its lifetime, especially any MLS-specific
   key material such as leaf encryption keys or init keys.

   This leaves the generation of authentication key material, which can
   also be based on exporters from the emulation group, but which
   otherwise depends on the design of the AS.  In the context of virtual
   clients, one should note, however, that the specifics of the AS can
   influence how well the virtual client hides the metadata of the
   underlying emulator clients.

   TODO: Be more explicit on how the randomness is exported.

4.10.  Coordinating virtual client operations

   Generally, emulator clients should coordinate the actions taken by
   the virtual client.  This is, for example, to prevent multiple
   emulator clients from uploading KeyPackages simultaneously.

   However, emulator clients do not have to coordinate all actions taken
   by the virtual client.  Specifically, commits in a single higher-
   level group can be sent without the risk of desynchronization between
   the emulator clients, as the group’s DS will enforce message
   ordering.  Coordination is thus required for non-commit messages
   (specifically proposals and application messages), as well as actions
   that affect more than one higher-level group (such as credential
   updates, depending on the AS).

4.11.  Possible message re-ordering

   One difficulty in coordinating the use of randomness exported from
   the emulation group is that we cannot assume that messages arrive in
   order.  For example, if an emulator client sends an Update in the
   emulation group and then immediately exports randomness from the new
   epoch to have the virtual client create an update in the higher-level
   group, then other emulator clients might receive the update in the
   higher-level group first.  Since they have not yet received the other
   update, they will have to wait for the emulation group update before
   they can process it.  Depending on the DS, this may or may not
   require specific care.

   TODO: Add a recommendation here, maybe to extract randomness only
   from emulation group epochs that are at least X seconds old, which in
   turn requires clients to keep around randomness, thus potentially
   compromising FS somewhat.

   In addition, since the epochs in the emulation group and higher level
   group are not necessarily correlated, i.e. an emulator client
   performing an update in the higher level group might not at the same
   time perform an update in the emulation group.  The emulator client
   performing the update in the higher level group thus has to signal
   the other emulator clients which emulation group epoch to use to
   export the randomness.

   TODO: Find a good way to signal this to the rest of the emulation
   group.  Options:

   *  AAD of the higher-level group update (leaks metadata to higher-
      level groups, could collide with application-level use of AAD)

   *  Application message to emulation group (subject to message re-
      ordering as described above)

   *  LeafNode extension (leaks metadata to higher-level groups)

4.12.  Adding emulator clients

   If a client is added to the emulation group, it has to be provisioned
   with the private key material and the group states of all higher-
   level groups.  While the latter might be able to be provisioned by
   the higher-level DS, the former has to be provided by another
   emulator client.

   The other emulator client can provide the secret key material used to
   derive all key material relevant to the virtual client (higher-level
   group secrets, KeyPackage secrets, etc.)

   TODO: This means that all such key material must be derived in a
   well-separated and forward-secure way.  (See TODO above to specify
   further details on how to derive key material for the virtual
   client.)

   Since the new emulator client can only emulate the virtual client if
   it has access to those secrets, it cannot join the emulation group
   via external commit, except if said secrets are provided
   asynchronously.

4.13.  Sending application messages

   Open Question: Key material for encryption/decryption of application
   messages is used only once.  Since there is no ordering of
   application messages (per client) on the DS, emulator clients could
   have the same virtual client send an application message at the same
   time, both using the same key material.  When those messages arrive
   at a recipient, the recipient won’t be able to decrypt the second
   message, because the recipient has already discarded the required key
   material.  How to avoid this?  A few ideas:

   *  Key generation allotments: Clients in the emulation group use the
      ratchet generation modulo their leaf index in the emulation group.
      (Leaks metadata to higher-level groups, potentially requires all
      other higher-level group members to store lots of intermediary key
      generations, could confuse applications if they derive message
      ordering from key generations, could make recipients think that
      they missed messages)

   *  More complex secret tree (or separate secret tree): Instead of a
      single ratchet at the leaf of the secret tree, there is another
      tree with one ratchet for each emulator client. (extra costs for
      PPRF, leaks metadata, requires an extension, either an unsafe one
      (if the original secret tree is modified), or a safe one that
      defines its own application message (if a new secret tree is
      used))

4.13.1.  PPRF-based Challenges

   Key/nonce pairs used to encrypt application messages are derived
   using a PPRF.  That is, the Secret Tree in the super group is
   replaced by a GGM-style PPRF initially keyed by the
   encryption_secret.  To send an application messaage, the sending
   emulator client choose a 32 byte challenge and includes it in the
   authenticated_data field in the PrivateMessage struct.  To derive the
   nonce and AEAD key for the application message the PPRF is evaluated
   (and punctured) the PPRF at the challenge.  Due to the entropy in the
   challenge nonce-reuse guards can be dropped.

   Advantages: - Group Structure Agnostic : The construction is agnostic
   to all aspects of the group's membership structure.  For example,
   clients can receive application messages without knowing the sender's
   leaf index in it's virtual client nor the relative position of the
   sender's virtual client in the hiearchy of virtual clients making up
   the super group. - Metadata Hiding: The scheme hides everything about
   a sender's position in the groups membership heirachy beyond what is
   revealed by the signature.  For example, application messages are as
   unlinkabel as permited by their signatures (even for other emulation
   clients in the same virtual client). - Forward Security Sender
   Anonymity : Leaking a clients PPRF local state reveals nothing about
   who sent previously received application messages.  This includes
   both hiding both the sending emulation clients and even their virtual
   clients.

   Disadvantages: - Breaks the RFC9420 specification & requires an un-
   safe extension. - Applications messages have an added 28 byte
   overhead. - Senders need 28 additional random bytes to send an
   application message. - A decryption error occurs when receiving an
   application message with a previously used challenge (in the current
   epoch).

   There is a trade-off between cost and error probability when choosing
   b; the bit-length of challenges.  (Above b = 256 which is very
   conservative.) - Sending two application messages with the same
   challenge in an epoch immediatly leaks the XOR of the two plaintexts
   and results in decryption failures for which ever message a client
   receives second.  The probability a challenge gets re-used when k
   application messages with b-bit challenges are sent in an epoch
   (without any coordination) is err = 1-[C(2^b,k)/C(2^b+k-1)].  So
   larger b reduces the probability of challenge re-use exponentially. -
   Evaluating the PPRF requires up to b HKDF calls and new 32B values to
   be stored locally by the client.  Moreover, b-bit challenges impost a
   8b-4 bytes of overhead in application messages and added random bits
   when sending.

4.14.  Rotation of authentication key material

   If the design of the AS specifies the use of cross-group
   authentication key material, emulator clients must coordinate the
   rotation of said key material in the emulation group to avoid
   multiple emulator clients rotating a key at the same time.  Details
   depend on the design of the AS.

5.  Security considerations

   TODO: Detail security considerations once the protocol has evolved a
   little more.  Starting points:

   Some of the performance benefits of this scheme depend on the fact
   that one can update once in the emulation group and “re-use” the new
   randomness for updates in multiple higher-level groups.  At that
   point, clients only really recover when they update the emulation
   group, i.e. re-using somewhat old randomness of the emulation group
   won’t provide real PCS in higher-level groups.

6.  Privacy considerations

   TODO: Specify the metadata hiding properties of the protocol.  The
   details depend on how we solve some of the problems described
   throughout this document.  However, using a virtual client should
   mask add/remove activity in the underlying emulation group.  If it
   actually hides the identity of the members may depend on the details
   of the AS, as well as how we solve the application messages problem.

7.  Performance considerations

   There are several use cases, where a specific group of clients
   represents a higher-level entity such as a user, or a part of an
   organization.  If that group of clients shares membership in a large
   number of groups, where its sole purpose is to represent the higher-
   level entity, then instead emulating a virtual client can yield a
   number of performance benefits, especially if this strategy is
   employed across an implementation.  Generally, the more emulator
   clients are hidden behind a single virtual client and the more
   clients are replaced by virtual clients, the higher the potential
   performance benefits.

7.1.  Smaller Trees

   As a general rule, groups where one or more sets of clients are
   replaced by virtual clients have fewer members, which leads to
   cheaper MLS operations where the cost depends on the group size,
   e.g., commits with a path, the download size of the group state for
   new members, etc.  This increase in performance can offset
   performance penalties, for example, when using a PQ-secure cipher
   suite, or if the application requires high update frequencies
   (deniability).

7.2.  Fewer blanks

   Blanks are typically created in the process of client removals.  With
   virtual clients, the removal of an emulator client will not cause the
   leaf of the virtual client (or indeed any node in the virtual
   client’s direct path) to be blanked, except if it is the last
   remaining emulator client.  As a result, fluctuation in emulator
   clients does not necessarily lead to blanks in the group of the
   corresponding virtual clients, resulting in fewer overall blanks and
   better performance for all group members.

8.  Emulation costs

   From a performance standpoint, using virtual clients only makes sense
   if the performance benefits from smaller trees and fewer blanks
   outweigh the performance overhead incurred by emulating the virtual
   client in the first place.

Authors' Addresses

   Konrad Kohbrok
   Phoenix R&D
   Email: konrad.kohbrok@datashrine.de


   Raphael Robert
   Phoenix R&D
   Email: ietf@raphaelrobert.com
