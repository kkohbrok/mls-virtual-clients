---
title: MLS Virtual Clients
abbrev: MVC
docname: draft-kohbrok-mls-virtual-clients-latest
category: info

ipr: trust200902
area: Security
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -  ins: K. Kohbrok
    name: Konrad Kohbrok
    organization: Phoenix R&D
    email: konrad.kohbrok@datashrine.de
 -  ins: R. Robert
    name: Raphael Robert
    organization: Phoenix R&D
    email: ietf@raphaelrobert.com

--- abstract

This document describes a method that allows multiple MLS clients to emulate a
virtual MLS client. A virtual client allows multiple emulator clients to jointly
participate in an MLS group under a single leaf. Depending on the design of the
application, virtual clients can help hide metadata and improve performance.

--- middle

# Introduction

The MLS protocol facilitates communication between clients, where in an MLS
group, each client is represented by the leaf to which it holds the private key
material. In this document, we propose the notion of a virtual client that is
jointly emulated by a group of emulator clients, where each emulator client
holds the key material necessary to act as the virtual client.

Depending on the use case, the use of virtual clients can lead to performance
increases and hide metadata from the DS and other group members. On the other
hand, it introduces complexity and additional operational requirements.

We discuss technical challenges and propose a concrete scheme that allows a
group of clients to emulate a virtual client that can participate in one or more
MLS groups.

# Terminology

- Client: An MLS client
- Virtual Client: A client the key material of which is held by one or more
  (other) clients.
- Emulator Client: A client that collaborates with other emulator clients in
  emulating a virtual client. Emulator clients can themselves be virtual
  clients.

TODO: Terminology is up for debate. We’ve sometimes called this “user trees”,
but since there are other use cases, we should choose a more neutral name. For
now, it’s virtual client emulation.

# Client emulation

To emulate a virtual client, the emulator clients need to agree on the key
material held by the virtual client and coordinate the actions taken by the
client in any group of which it is a member. The obvious way for the emulator
clients to achieve both of these tasks is to create an MLS group which we call
the emulation group. In contrast, we call any group that the virtual client is a
member of a higher-level group.

## Example protocol flow

TODO: Go through a full flow, where both sender and receiver are virtual
clients. Include both communication in the higher-level group and in the
emulation group.

## DS/AS Details

Virtual client emulation should be largely agnostic to specific details of the
AS and DS of the application. However, a few conditions must be met.

- Access control: All emulator clients must be able to act as the virtual
  client, including, for example, queue access and KeyPackage upload
- Queue compatibility: The queue system must allow all emulator clients to
  retrieve messages for the virtual clients. (Although workarounds like one
  emulator client retrieving messages and then sending them to the emulation
  group are possible.)

## Agreement on/generation of key material

Agreement on key material is one of the primary features of MLS and the emulator
clients can simply export secrets from the emulation group to provide the
randomness for all key material generated by the virtual client throughout its
lifetime, especially any MLS-specific key material such as leaf encryption keys
or init keys.

This leaves the generation of authentication key material, which can also be
based on exporters from the emulation group, but which otherwise depends on the
design of the AS. In the context of virtual clients, one should note, however,
that the specifics of the AS can influence how well the virtual client hides the
metadata of the underlying emulator clients.

TODO: Be more explicit on how the randomness is exported.

## Coordinating virtual client operations

Generally, emulator clients should coordinate the actions taken by the virtual
client. This is, for example, to prevent multiple emulator clients from
uploading KeyPackages simultaneously.

However, emulator clients do not have to coordinate all actions taken by the
virtual client. Specifically, commits in a single higher-level group can be sent
without the risk of desynchronization between the emulator clients, as the
group’s DS will enforce message ordering. Coordination is thus required for
non-commit messages (specifically proposals and application messages), as well
as actions that affect more than one higher-level group (such as credential
updates, depending on the AS).

## Possible message re-ordering

One difficulty in coordinating the use of randomness exported from the emulation
group is that we cannot assume that messages arrive in order. For example, if an
emulator client sends an Update in the emulation group and then immediately
exports randomness from the new epoch to have the virtual client create an
update in the higher-level group, then other emulator clients might receive the
update in the higher-level group first. Since they have not yet received the
other update, they will have to wait for the emulation group update before they
can process it. Depending on the DS, this may or may not require specific care.

TODO: Add a recommendation here, maybe to extract randomness only from emulation
group epochs that are at least X seconds old, which in turn requires clients to
keep around randomness, thus potentially compromising FS somewhat.

In addition, since the epochs in the emulation group and higher level group are
not necessarily correlated, i.e. an emulator client performing an update in the
higher level group might not at the same time perform an update in the emulation
group. The emulator client performing the update in the higher level group thus
has to signal the other emulator clients which emulation group epoch to use to
export the randomness.

TODO: Find a good way to signal this to the rest of the emulation group. Options:

- AAD of the higher-level group update (leaks metadata to higher-level groups,
  could collide with application-level use of AAD)
- Application message to emulation group (subject to message re-ordering as
  described above)
- LeafNode extension (leaks metadata to higher-level groups)

## Adding emulator clients

If a client is added to the emulation group, it has to be provisioned with the
private key material and the group states of all higher-level groups. While the
latter might be able to be provisioned by the higher-level DS, the former has to
be provided by another emulator client.

The other emulator client can provide the secret key material used to derive all
key material relevant to the virtual client (higher-level group secrets,
KeyPackage secrets, etc.)

TODO: This means that all such key material must be derived in a well-separated
and forward-secure way. (See TODO above to specify further details on how to
derive key material for the virtual client.)

Since the new emulator client can only emulate the virtual client if it has
access to those secrets, it cannot join the emulation group via external commit,
except if said secrets are provided asynchronously.

## Sending application messages

Open Question: Key material for encryption/decryption of application messages is
used only once. Since there is no ordering of application messages (per client)
on the DS, emulator clients could have the same virtual client send an
application message at the same time, both using the same key material. When
those messages arrive at a recipient, the recipient won’t be able to decrypt the
second message, because the recipient has already discarded the required key
material. How to avoid this? A few ideas:

- Key generation allotments: Clients in the emulation group use the ratchet
  generation modulo their leaf index in the emulation group. (Leaks metadata to
  higher-level groups, potentially requires all other higher-level group members
  to store lots of intermediary key generations, could confuse applications if
  they derive message ordering from key generations, could make recipients think
  that they missed messages)
- More complex secret tree (or separate secret tree): Instead of a single
  ratchet at the leaf of the secret tree, there is another tree with one ratchet
  for each emulator client. (extra costs for PPRF, leaks metadata, requires an
  extension, either an unsafe one (if the original secret tree is modified), or
  a safe one that defines its own application message (if a new secret tree is
  used))

### Challenge-based Application Messages
The MLS specification defines a method for sending application messages. To use that method, senders and receivers must know to which ratchet tree leaf the sending client belongs which precludes the possibility of group members sending anonymously to the group; a property that can be desirable for some applications. The method is designed with receivers in mind that process application messages in roughly the order they were sent. Consequently, receivers the method imposes significant computational and storage costs for receivers that want skip several application messages to access a more recently sent one directly. For example, skipping `j` application messages sent by the same client requires at least `j` calls to `ExpandWithLable` and requires storing `j` secrets for possible later use.

To better support anonymous sending and random-access processing of application messages, the extension to {{!RFC9420}} described in this section introduces an alternate method for sending application messages called "challenge-based" application messagees. The method does not require receivers know the senders ratchet tree leaf. It also allows processing incoming application messages with a cost independent of the order they are received in. The extension exclusively uses the Safe Extension API of draft-03 of {{!I-D.draft-ietf-mls-extensions}}; i.e. using that draft's terminology it is a "safe extension".

In comparison MLS's standard applcation messages, challenge-based application messages are KDF.Nh - 4 bytes larger. Sending and receiving them require (at most) KDF.Nh calls to ExpandWithLabel and storing one secret of size KDF.Nh octets per such call. This holds for the receiver regardless of how many previouse application messages from the same sender were skipped by the receiver.

Challenge-based messages can be sent either in one of three modes: random-access, private-anonymous or public-anonymous mode. Random-access mode application message can be validated and decrypted at a cost independent of how many messages tehe receiver has skipped. In adition, the two anonymous modes omit any data that could reveal the senders leaf index, authenticating only that the sender is in the group. In the private-anonymous mode this can only be verified by other group members. With the public-anonymous mode the group membership of the sender can be verified by external (i.e. non-member) parties such as a server acting as part of the DS. The anonymous modes come at a price in terms of a slightly weaker flavour of post comporomise message authenticity described in {{security-considerations-for-anonymous-modes}}. Applications can send each new application message using a different mode which can be chosen when sending.

#### Challenge Selection

To send an application message the sender must first sample a challenge. It is crucial for application message confidentiality that challenges have high entropy and are never used more than once. The following method for sampling challenges ensures this by introducing sufficient entropy and guaranting that two challenges can only ever be the same if they are sampled by the same sender, in the same epoch, for the same message generation using the same entropy.

For each epoch in which a client wants to send challenge-based application messages it maintains a local uint32 message generation counter for the epoch. The counter is initilized to 0 and incremented after each challenge is sampled. If the counter wraps around to 0 then all subsequent attempts by the client to send in the epoch MUST result in a failure.

~~~~
uint32 generation;
~~~~

To sample a challenge the sender first samples AEAD.Nk uniform random octets called the challenge-seed. Next the they populate a ChallengeContext including their leaf index, the current generation counter and a hash of the GroupContext. (A hash is used to avoid having to evaluate the KDF on the, possibly quite large, GroupContext struct each time a new challenge is sampled.) The application may supply further context in the applicaiton_context field. Finally, the challenge is derived from the challenge-seed and ChallengeContext using the KDF and tehe generation counter is incremented.

~~~~
group_context_hash = Hash(GroupContext)

struct {
	opaque group_context_hash;
	uint32 sender_leaf_index;
	opaque application_context;
} ChallengeContext

challenge = KDF.Expand(challenge-seed, ChallengeContext, KDF.Nh)
~~~~

#### Message Framing
The following enum and structs define the wire format for challenge-based application messages.

~~~~
enum {
	reserved(0),
    random-access(1),
	private-anonymous(2),
	public-anonymous(3),
	(256)
} CBAMSenderMode

struct {
    CBAMSenderMode mode;
	uint8 challenge[KDF.Nh];
    select (CBAMSender.mode) {
        case random-access:
            uint32 leaf_index;
        case priavte-anonymous:
        case public-anonymous:
            struct{};
    };
} CBAMSender;

struct {
    ProtocolVersion version = mls10;
    WireFormat wire_format;
    CBAMPrivateMessage private_message;
} CBAMMLSMessage;
~~~~


#### Message Authentication
The following structs are used to authenticate data in a challenge-based application message. When using random-access mode, this is done almost identically to standard application messages. In public-anonymous mode the signature is producing using the groups signature keys described in {{group-signature-keys}}. The private-anonymous mode omits signatures entirely.

~~~~

// See the "MLS Wire Formats" IANA registry for values
uint16 WireFormat;

struct {
    opaque group_id<V>;
    uint64 epoch;
    CBAMSender sender;
    opaque authenticated_data<V>;
	opaque application_data<V>;
} CBAMFramedContent

struct {
    ProtocolVersion version = mls10;
    WireFormat wire_format;
    CBAMFramedContent content;
	GroupContext context;
} CBAMFramedContentTBS;

struct {
	select(FramedContentTBS.content.sender.mode) {
		case random-access:
		case public-anonymous:
			/* SignWithLabel(., "CBAMFramedContentTBS", CBAMFramedContentTBS) */
			opaque signature<V>;
		case private-anonymous:
			struct{};
	}
} CBAMFramedContentAuthData;

struct {
    WireFormat wire_format;
    CBAMFramedContent content;
    CBAMFramedContentAuthData auth;
} CBAMAuthenticatedContent;
~~~~

Challenge-based application messages are encoded, authenticated and encrypted much like MLS private messages using the CBAMPrivateMessage struct.

~~~~
struct {
    opaque group_id<V>;
    uint64 epoch;
    opaque authenticated_data<V>;
    opaque encrypted_cbam_sender_data<V>;
    opaque cbam_encrypted_cbam_private_message_content<V>;
} CBAMPrivateMessage;
~~~~

#### Content Encryption

Content to be encrypted is encoded with a CBAMPrivateMessageContent and the Additional Authenticated data is encoded with a CBAMPrivateContentAAD. The key and nonce used for encryption are derived from the challenge using the FS-KDF described in {{forward-secure-kdf}}.

~~~~
struct {
	opaque application_data<V>;
    CBAMFramedContentAuthData auth;
    opaque padding[length_of_padding];
} CBAMPrivateMessageContent;

struct {
    opaque group_id<V>;
    uint64 epoch;
    opaque cbam_authenticated_data<V>;
} cbam_PrivateContentAAD;

aead_key = FS-KDF.Eval(challenge, "key")

aead_nonce = FS-KDF.Eval(challenge, "nonce")
~~~~

#### Sender Data Encryption
The encrypted_cbam_sender_data is obtained by encrypting the CBAMSenderData using keys derived from the cbam_sender_data_secret. This secret is exported using the safe API's forward-secure exporter function MLS-FS-Exporter using the label "CBAM Sender Data Secret" and an empty context. Other than that, the same method is used to encrypt sender data as for standard application messages.

~~~~
cbam_sender_data_secret = MLS-FS-Export("CBAM Sender Data Secret", "", KDF.Nk)

ciphertext_sample = ciphertext[0..KDF.Nh-1]

sender_data_key = ExpandWithLabel(cbam_sender_data_secret, "key",
                      ciphertext_sample, AEAD.Nk)
sender_data_nonce = ExpandWithLabel(cbam_sender_data_secret, "nonce",
                      ciphertext_sample, AEAD.Nn)
~~~~

#### Forward Secure KDF
Describe how the PPRF based secret tree works for mapping challenges to key/nonce pairs.
- derive cbam_encryption_secret using MLS-FS-Exporter.
- define key, nonce for a given challenge.
- specify deletion schedule.

#### Group Signature Keys
- DeriveSigKeyPair along the lines of DeriveKeyPair in HPKE {{!RFC9180}}.
- Derive cbam_sender_data_secret.

#### Security Considerations For Anonymous Modes
- Weaker PCS Authenticity.

#### Legacy Text

Key/nonce pairs used to encrypt application messages are derived using a PPRF.
That is, the Secret Tree in the super group is replaced by a GGM-style PPRF
initially keyed by the `encryption_secret`. To send an application messaage,
the sending emulator client choose a 32 byte challenge and includes it in the
`authenticated_data` field in the `PrivateMessage` struct. To derive the nonce
and AEAD key for the application message the PPRF is evaluated (and punctured)
the PPRF at the challenge. Due to the entropy in the challenge nonce-reuse
guards can be dropped.

Advantages:
- Group Structure Agnostic : The construction is agnostic to all aspects of the
group's membership structure. For example, clients can receive application
messages without knowing the sender's leaf index in it's virtual client nor
the relative position of the sender's virtual client in the hiearchy of virtual
clients making up the super group.
- Metadata Hiding: The scheme hides everything about a sender's position in the
groups membership heirachy beyond what is revealed by the signature. For
example, application messages are as unlinkabel as permited by their signatures
(even for other emulation clients in the same virtual client).
- Forward Security Sender Anonymity : Leaking a clients PPRF local state reveals
nothing about who sent previously received application messages. This includes
both hiding both the sending emulation clients and even their virtual clients.

Disadvantages:
- Breaks the RFC9420 specification & requires an un-safe extension.
- Applications messages have an added 28 byte overhead.
- Senders need 28 additional random bytes to send an application message.
- A decryption error occurs when receiving an application message with a
previously used challenge (in the current epoch).

There is a trade-off between cost and error probability when choosing `b`; the
bit-length of challenges. (Above `b = 256` which is very conservative.)
- Sending two application messages with the same challenge in an epoch
immediatly leaks the XOR of the two plaintexts and results in decryption
failures for which ever message a client receives second. The probability a
challenge gets re-used when `k` application messages with `b`-bit challenges
are sent in an epoch (without any coordination) is
`err = 1-[C(2^b,k)/C(2^b+k-1)]`. So larger `b` reduces the probability of
challenge re-use exponentially.
- Evaluating the PPRF requires up to `b` HKDF calls and new 32B values to be
stored locally by the client. Moreover, `b`-bit challenges impost a `8b-4` bytes
of overhead in application messages and added random bits when sending.

## Rotation of authentication key material

If the design of the AS specifies the use of cross-group authentication key
material, emulator clients must coordinate the rotation of said key material in
the emulation group to avoid multiple emulator clients rotating a key at the
same time. Details depend on the design of the AS.

# Security considerations

TODO: Detail security considerations once the protocol has evolved a little
more. Starting points:

Some of the performance benefits of this scheme depend on the fact that one can
update once in the emulation group and “re-use” the new randomness for updates
in multiple higher-level groups. At that point, clients only really recover when
they update the emulation group, i.e. re-using somewhat old randomness of the
emulation group won’t provide real PCS in higher-level groups.

# Privacy considerations

TODO: Specify the metadata hiding properties of the protocol. The details depend
on how we solve some of the problems described throughout this document.
However, using a virtual client should mask add/remove activity in the
underlying emulation group. If it actually hides the identity of the members may
depend on the details of the AS, as well as how we solve the application
messages problem.

# Performance considerations

There are several use cases, where a specific group of clients represents a
higher-level entity such as a user, or a part of an organization. If that group
of clients shares membership in a large number of groups, where its sole purpose
is to represent the higher-level entity, then instead emulating a virtual client
can yield a number of performance benefits, especially if this strategy is
employed across an implementation. Generally, the more emulator clients are
hidden behind a single virtual client and the more clients are replaced by
virtual clients, the higher the potential performance benefits.

## Smaller Trees

As a general rule, groups where one or more sets of clients are replaced by
virtual clients have fewer members, which leads to cheaper MLS operations where
the cost depends on the group size, e.g., commits with a path, the download size
of the group state for new members, etc. This increase in performance can offset
performance penalties, for example, when using a PQ-secure cipher suite, or if
the application requires high update frequencies (deniability).

## Fewer blanks

Blanks are typically created in the process of client removals. With virtual
clients, the removal of an emulator client will not cause the leaf of the
virtual client (or indeed any node in the virtual client’s direct path) to be
blanked, except if it is the last remaining emulator client. As a result,
fluctuation in emulator clients does not necessarily lead to blanks in the group
of the corresponding virtual clients, resulting in fewer overall blanks and
better performance for all group members.

# Emulation costs

From a performance standpoint, using virtual clients only makes sense if the
performance benefits from smaller trees and fewer blanks outweigh the
performance overhead incurred by emulating the virtual client in the first
place.
